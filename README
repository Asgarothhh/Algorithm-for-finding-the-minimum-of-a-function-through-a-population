В данной программе я реализовал алгоритм поиска минимума функции при помощи рандомно сгенерированной популяции чисел.
Значения массива, хранящего значения популяции, мы изначально присваиваем массиву, хранящему значения функции.
После этого происходит отбор: мы изменяем числа популяции (<особи>) на определённый шаг, после чего передаём новую <особь>
в функцию. Далее мы сравниваем новое значение функции с ранее записанным: если оно меньше ранее записанного, то мы заменям старое значение 
новым, а в массиве <особей> заменяем старую <особь> на новую. В противном случае не выполняем никаких действий.
Таким образом, мы получаем различные значения функции, среди которых потом произведём очередную выборку в поисках минимума.
Для поиска минимума функции необходимо постоянно уменьшать шаг, для этого в программе инициализирован коэффициент затухания (важно 
подобрать шаг и коэффициент затухания наиболее оптимальными, иначе мы рискуем либо пропустить искомый минимум, либо вовсе не добраться до него. Я сделал
это методом подбора).
Массивы, хранящие популяции и значения функции, являются двумерными. По сути, каждый из них представляет собой "таблицу" в 1000 строк и 3 столбца.
В конце программы из каждого столбца выводится лучшее значение функции, на основании которых мы в последствии выбираем самое маленькое значение функции.
Примечание: по сути было сгенерировано 3 популяции по 1000 элементов в каждой, но для простоты восприятия в коде я оформил это как 1000 популяций по 3 элемента.
Это является исключительно визуальным (?) решением.
